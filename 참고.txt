-EXISTS       (서브쿼리)  : 서브 쿼리에 존재하는 행을 반환.
-NOT EXISTS (서브쿼리) : 서브 쿼리에 존재하지 않는 행을 반환한다.


FOR a IN (SELECT * FROM t1) LOOP
      FOR b IN (SELECT * FROM t2 b WHERE b.c1 = a.c1) LOOP
            EXIT;
      END LOOP;
      결과 반환
END LOOP;


WITH 절(12.1 버전부터 PL/SQL 함수와 프로시저를 선언해 사용가능)

WITH 쿼리_네임1 AS (서브쿼리)
     ,  쿼리_네임2 AS (서부쿼리)
     ,    ......
SELECT * FROM 쿼리_네임1 ,쿼리_네임2 ,...



-----( 이건 회사환경에서 사용 X 11.1버전임)
WITH 
      FUNCTION f1 (i_val IN VARCHAR2) RETURN NUMBER IS
             l_val NUMBER;
      BEING
            EXECUTE IMMEDIATE 'SELECT  ' || i_val || ' FROM DUAL' INTO l_val;
            RETURN l_val;
      END;

SELECT f1 ( ' ((1+2) * 3) / 4 ' ) AS c1 FROM DUAL;
------



-UNION ALL : 데이터를 수평으로 연결 합집합(중복항목 출력)

SELECT C1 FROM T1
UNION ALL
SELECT C1 FROM T2;            
=> C1 열에 T1, T2 테이블 모든 데이터 출력.


-UNION : 중복값이 제거된 합집합 생성 (*중복을 제거하기 위해 sort 발생)

SELECT C1 FROM T1
UNION
SELECT C1 FROM T2;
=> C1 열에 중복값이 제거된 T1, T2 테이블 데이터 출력

** UNION은 중복을 제거해 출력된다. 조회하는 값에서 유일성이 있는 키를 함께 사용하게 되면
UNION ALL 과 같은 결과가 나온다. 불필요한 (sort) 처리를 막기위해 UNION ALL을 사용해야한다. **


-INTERSECT : 중복 값이 제거된 교집합을 생성한다. (*sort 발생)
SELECT C1 FROM T1     -- A, B, Z
INTERSECT
SELECT C1 FROM T2;    -- B, C, Z
=> C1||||| B, Z 


-MINUS : 중복 값이 제거된 차집합을 생성한다. (*sort 발생)
SELECT C1 FROM T1     -- A, B, Z
MINUS
SELECT C1 FROM T2;    -- B, C, Z
=> C1||||| A

연결되는 열의 개수가 다르면 에러! 데이터 타입도 다르면 에러!

OR 조건을 여러개 사용하면 쿼리 성능 저하가 일어난다
집합 연산자로 데이터 집합을 분리하면 성능이 개선된다.



// 책 예제............................ HAVING 절만 써서 집계
 SELECT SUM(sal) AS sal
  FROM emp
HAVING SUM(sal) > 25000;

   SAL
-------
   29025

.... 연습용 테이블에 사용해 봤지만 HAVING 쓰든 안쓰든 모든 SALARY의 합이 구해진다...
.... WHERE 절과 유사하게 동작한다고 적혀있지만....
.... 책은 HAVING절이 먼저 실행되는거 같은데 나는 SELECT 절이 먼저 실행되는 느낌...
