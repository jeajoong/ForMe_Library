-EXISTS     (서브쿼리) : 서브 쿼리에 존재하는 행을 반환.
-NOT EXISTS (서브쿼리) : 서브 쿼리에 존재하지 않는 행을 반환한다.


FOR a IN (SELECT * FROM t1) LOOP
      FOR b IN (SELECT * FROM t2 b WHERE b.c1 = a.c1) LOOP
            EXIT;
      END LOOP;
      결과 반환
END LOOP;


WITH 절(12.1 버전부터 PL/SQL 함수와 프로시저를 선언해 사용가능)

WITH 쿼리_네임1 AS (서브쿼리)
  ,  쿼리_네임2 AS (서부쿼리)
  ,    ......
SELECT * FROM 쿼리_네임1 ,쿼리_네임2 ,...



-----( 이건 회사환경에서 사용 X 11.1버전임)
WITH 
      FUNCTION f1 (i_val IN VARCHAR2) RETURN NUMBER IS
             l_val NUMBER;
      BEING
            EXECUTE IMMEDIATE 'SELECT  ' || i_val || ' FROM DUAL' INTO l_val;
            RETURN l_val;
      END;

SELECT f1 ( ' ((1+2) * 3) / 4 ' ) AS c1 FROM DUAL;
------



-UNION ALL : 데이터를 수평으로 연결 합집합(중복항목 출력)

SELECT C1 FROM T1
UNION ALL
SELECT C1 FROM T2;            
=> C1 열에 T1, T2 테이블 모든 데이터 출력.


-UNION : 중복값이 제거된 합집합 생성 (*중복을 제거하기 위해 sort 발생)

SELECT C1 FROM T1
UNION
SELECT C1 FROM T2;
=> C1 열에 중복값이 제거된 T1, T2 테이블 데이터 출력

** UNION은 중복을 제거해 출력된다. 조회하는 값에서 유일성이 있는 키를 함께 사용하게 되면
UNION ALL 과 같은 결과가 나온다. 불필요한 (sort) 처리를 막기위해 UNION ALL을 사용해야한다. **


-INTERSECT : 중복 값이 제거된 교집합을 생성한다. (*sort 발생)
SELECT C1 FROM T1     -- A, B, Z
INTERSECT
SELECT C1 FROM T2;    -- B, C, Z
=> C1||||| B, Z 


-MINUS : 중복 값이 제거된 차집합을 생성한다. (*sort 발생)
SELECT C1 FROM T1     -- A, B, Z
MINUS
SELECT C1 FROM T2;    -- B, C, Z
=> C1||||| A


연결되는 열의 개수가 다르면 에러! 데이터 타입도 다르면 에러!

OR 조건을 여러개 사용하면 쿼리 성능 저하가 일어난다
집합 연산자로 데이터 집합을 분리하면 성능이 개선된다.



// 책 예제............................ HAVING 절만 써서 집계
 SELECT SUM(sal) AS sal
  FROM emp
HAVING SUM(sal) > 25000;

   SAL
-------
   29025
.... 똑같이 작성해봐도 모든 sal의 합이 나온다 HAVING 절을 사용하지 않아도 똑같다...
.... 차라리 그냥 WHERE 절로 WHERE SAL > 25000 하는게 더 속편한...



-REPLACE : 문자를 변환한다 (정확하게 바꾼다면)
-TRANSLATE : 문자를 변환한다 (변환하려는 문자와 자리수를 따짐)
 SELECT TRANSLATE ('AAABBC', 'AB', '1'  ) AS C1  => 111C   / 문자열 자체에 A와 B를 읽어들여 1로 표기, A가 한개 남는거 그냥 1로 표기하는 듯
      , TRANSLATE ('AAABBC', 'AB', '1 ' ) AS C2  => 111  C / 'A'를 1로 'B'를 ' '으로 변환
      , TRANSLATE ('AAABBC', 'AB', '123') AS C3  => 11122C / 'AB' 1,2로 대체되는 듯함. 3은 버려짐.
   FROM DUAL; 

